# PPT页面
## 第一页
[不改]
## 第二面
【不改】
## 第三面
基础功能全部完成的下面，改为
- 键盘鼠标交互
- 三维空间里的视角转换
- 快捷键生成常用模型
- 三维模型的重合与碰撞检测
- 以及模型的格式化保存与加载
## 第六面（代码组织）
【放类图】
**文字**
解耦的思想遍布整个项目。各个类各司其职，又在一定程度上相互交互。
## 第六(2)面（增添，还是代码组织）
【放Node的继承关系图】
**文字**
Node作为3D对象的基类，定义了场景中节点的基本操作，如平移、旋转、拉伸等。

Primitive类真正实现了结点的渲染操作。

HierarchicalNode类继承于Node类，又包含着一个3D对象list，负责递归地渲染各个子对象。
## 第六（4）面（增添）
**文字**
代码解耦的一个例子：
``` python
...
    def trigger(self, name, *args, **kwargs):
        """ calls a callback, forwards the args """
        for func in self.callbacks[name]:
            func(*args, **kwargs)
```
## 第六（3）面（增添）
【放函数调用关系图】
例子：实现新功能，在拖动一个物体时，随着物体的移动，颜色逐渐改变。
在耦合度高的代码中，需要在鼠标回调函数的函数体中插入代码，调用物体的变色接口。

在本项目的解耦代码中，只需要将物体的变色接口注册到“回调函数”中。鼠标拖动物体时，变色接口会自动被触发。

增减功能极其方便

## 项目难点
1. OpenGL底层接口涉及大量繁复的细节。OpenGL属于一个较为底层的库，灵活运用该库需要了解大量的底层原理。
2. 线性代数的需求
本项目中，物体的坐标系变换、平移、伸缩、旋转等，需要大量运用矩阵变换。
3. 基于包围盒的与光线追踪的方法
    1. 当鼠标点击时，需要判断模型是否被选中。用二维的平面点击去判定是否击中三维的模型，需要包围盒算法和光线追踪。
    1. 光线追踪需要利用鼠标的位置，模拟一束射出的光线，判断各个物体的包围盒是否接触到光线。该算法的实现难度较大。
    1. 包围盒算法将物体的参差不齐的边缘简化为一个盒子。由于物体是处于世界坐标系中的，盒子也需要作相应的矩阵变换。

## 新的一页
放运行视频